{"ast":null,"code":"import { motionValue } from 'motion-dom';\nimport { useContext, useState, useEffect } from 'react';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\n\n/**\r\n * Creates a `MotionValue` to track the state and velocity of a value.\r\n *\r\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\r\n *\r\n * ```jsx\r\n * export const MyComponent = () => {\r\n *   const scale = useMotionValue(1)\r\n *\r\n *   return <motion.div style={{ scale }} />\r\n * }\r\n * ```\r\n *\r\n * @param initial - The initial state.\r\n *\r\n * @public\r\n */\nfunction useMotionValue(initial) {\n  const value = useConstant(() => motionValue(initial));\n  /**\r\n   * If this motion value is being used in static mode, like on\r\n   * the Framer canvas, force components to rerender when the motion\r\n   * value is updated.\r\n   */\n  const {\n    isStatic\n  } = useContext(MotionConfigContext);\n  if (isStatic) {\n    const [, setLatest] = useState(initial);\n    useEffect(() => value.on(\"change\", setLatest), []);\n  }\n  return value;\n}\nexport { useMotionValue };","map":{"version":3,"names":["motionValue","useContext","useState","useEffect","MotionConfigContext","useConstant","useMotionValue","initial","value","isStatic","setLatest","on"],"sources":["D:/portfolio-master/node_modules/framer-motion/dist/es/value/use-motion-value.mjs"],"sourcesContent":["import { motionValue } from 'motion-dom';\r\nimport { useContext, useState, useEffect } from 'react';\r\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\r\nimport { useConstant } from '../utils/use-constant.mjs';\r\n\r\n/**\r\n * Creates a `MotionValue` to track the state and velocity of a value.\r\n *\r\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\r\n *\r\n * ```jsx\r\n * export const MyComponent = () => {\r\n *   const scale = useMotionValue(1)\r\n *\r\n *   return <motion.div style={{ scale }} />\r\n * }\r\n * ```\r\n *\r\n * @param initial - The initial state.\r\n *\r\n * @public\r\n */\r\nfunction useMotionValue(initial) {\r\n    const value = useConstant(() => motionValue(initial));\r\n    /**\r\n     * If this motion value is being used in static mode, like on\r\n     * the Framer canvas, force components to rerender when the motion\r\n     * value is updated.\r\n     */\r\n    const { isStatic } = useContext(MotionConfigContext);\r\n    if (isStatic) {\r\n        const [, setLatest] = useState(initial);\r\n        useEffect(() => value.on(\"change\", setLatest), []);\r\n    }\r\n    return value;\r\n}\r\n\r\nexport { useMotionValue };\r\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,YAAY;AACxC,SAASC,UAAU,EAAEC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AACvD,SAASC,mBAAmB,QAAQ,oCAAoC;AACxE,SAASC,WAAW,QAAQ,2BAA2B;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAACC,OAAO,EAAE;EAC7B,MAAMC,KAAK,GAAGH,WAAW,CAAC,MAAML,WAAW,CAACO,OAAO,CAAC,CAAC;EACrD;AACJ;AACA;AACA;AACA;EACI,MAAM;IAAEE;EAAS,CAAC,GAAGR,UAAU,CAACG,mBAAmB,CAAC;EACpD,IAAIK,QAAQ,EAAE;IACV,MAAM,GAAGC,SAAS,CAAC,GAAGR,QAAQ,CAACK,OAAO,CAAC;IACvCJ,SAAS,CAAC,MAAMK,KAAK,CAACG,EAAE,CAAC,QAAQ,EAAED,SAAS,CAAC,EAAE,EAAE,CAAC;EACtD;EACA,OAAOF,KAAK;AAChB;AAEA,SAASF,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}