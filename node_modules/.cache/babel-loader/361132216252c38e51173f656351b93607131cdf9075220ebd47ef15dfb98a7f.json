{"ast":null,"code":"import { isGenerator, createGeneratorEasing } from 'motion-dom';\nimport { progress, secondsToMilliseconds, invariant } from 'motion-utils';\nimport { getEasingForSegment } from '../../easing/utils/get-easing-for-segment.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { fillOffset } from '../../utils/offsets/fill.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { resolveSubjects } from '../animate/resolve-subjects.mjs';\nimport { calculateRepeatDuration } from './utils/calc-repeat-duration.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { normalizeTimes } from './utils/normalize-times.mjs';\nimport { compareByTime } from './utils/sort.mjs';\nconst defaultSegmentEasing = \"easeInOut\";\nconst MAX_REPEAT = 20;\nfunction createAnimationsFromSequence(sequence, {\n  defaultTransition = {},\n  ...sequenceTransition\n} = {}, scope, generators) {\n  const defaultDuration = defaultTransition.duration || 0.3;\n  const animationDefinitions = new Map();\n  const sequences = new Map();\n  const elementCache = {};\n  const timeLabels = new Map();\n  let prevTime = 0;\n  let currentTime = 0;\n  let totalDuration = 0;\n  /**\r\n   * Build the timeline by mapping over the sequence array and converting\r\n   * the definitions into keyframes and offsets with absolute time values.\r\n   * These will later get converted into relative offsets in a second pass.\r\n   */\n  for (let i = 0; i < sequence.length; i++) {\n    const segment = sequence[i];\n    /**\r\n     * If this is a timeline label, mark it and skip the rest of this iteration.\r\n     */\n    if (typeof segment === \"string\") {\n      timeLabels.set(segment, currentTime);\n      continue;\n    } else if (!Array.isArray(segment)) {\n      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n      continue;\n    }\n    let [subject, keyframes, transition = {}] = segment;\n    /**\r\n     * If a relative or absolute time value has been specified we need to resolve\r\n     * it in relation to the currentTime.\r\n     */\n    if (transition.at !== undefined) {\n      currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n    }\n    /**\r\n     * Keep track of the maximum duration in this definition. This will be\r\n     * applied to currentTime once the definition has been parsed.\r\n     */\n    let maxDuration = 0;\n    const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {\n      const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n      const {\n        delay = 0,\n        times = defaultOffset(valueKeyframesAsList),\n        type = \"keyframes\",\n        repeat,\n        repeatType,\n        repeatDelay = 0,\n        ...remainingTransition\n      } = valueTransition;\n      let {\n        ease = defaultTransition.ease || \"easeOut\",\n        duration\n      } = valueTransition;\n      /**\r\n       * Resolve stagger() if defined.\r\n       */\n      const calculatedDelay = typeof delay === \"function\" ? delay(elementIndex, numSubjects) : delay;\n      /**\r\n       * If this animation should and can use a spring, generate a spring easing function.\r\n       */\n      const numKeyframes = valueKeyframesAsList.length;\n      const createGenerator = isGenerator(type) ? type : generators === null || generators === void 0 ? void 0 : generators[type];\n      if (numKeyframes <= 2 && createGenerator) {\n        /**\r\n         * As we're creating an easing function from a spring,\r\n         * ideally we want to generate it using the real distance\r\n         * between the two keyframes. However this isn't always\r\n         * possible - in these situations we use 0-100.\r\n         */\n        let absoluteDelta = 100;\n        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {\n          const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n          absoluteDelta = Math.abs(delta);\n        }\n        const springTransition = {\n          ...remainingTransition\n        };\n        if (duration !== undefined) {\n          springTransition.duration = secondsToMilliseconds(duration);\n        }\n        const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);\n        ease = springEasing.ease;\n        duration = springEasing.duration;\n      }\n      duration !== null && duration !== void 0 ? duration : duration = defaultDuration;\n      const startTime = currentTime + calculatedDelay;\n      /**\r\n       * If there's only one time offset of 0, fill in a second with length 1\r\n       */\n      if (times.length === 1 && times[0] === 0) {\n        times[1] = 1;\n      }\n      /**\r\n       * Fill out if offset if fewer offsets than keyframes\r\n       */\n      const remainder = times.length - valueKeyframesAsList.length;\n      remainder > 0 && fillOffset(times, remainder);\n      /**\r\n       * If only one value has been set, ie [1], push a null to the start of\r\n       * the keyframe array. This will let us mark a keyframe at this point\r\n       * that will later be hydrated with the previous value.\r\n       */\n      valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);\n      /**\r\n       * Handle repeat options\r\n       */\n      if (repeat) {\n        invariant(repeat < MAX_REPEAT, \"Repeat count too high, must be less than 20\");\n        duration = calculateRepeatDuration(duration, repeat);\n        const originalKeyframes = [...valueKeyframesAsList];\n        const originalTimes = [...times];\n        ease = Array.isArray(ease) ? [...ease] : [ease];\n        const originalEase = [...ease];\n        for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\n          valueKeyframesAsList.push(...originalKeyframes);\n          for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {\n            times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));\n            ease.push(keyframeIndex === 0 ? \"linear\" : getEasingForSegment(originalEase, keyframeIndex - 1));\n          }\n        }\n        normalizeTimes(times, repeat);\n      }\n      const targetTime = startTime + duration;\n      /**\r\n       * Add keyframes, mapping offsets to absolute time.\r\n       */\n      addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n      maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n      totalDuration = Math.max(targetTime, totalDuration);\n    };\n    if (isMotionValue(subject)) {\n      const subjectSequence = getSubjectSequence(subject, sequences);\n      resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n    } else {\n      const subjects = resolveSubjects(subject, keyframes, scope, elementCache);\n      const numSubjects = subjects.length;\n      /**\r\n       * For every element in this segment, process the defined values.\r\n       */\n      for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {\n        /**\r\n         * Cast necessary, but we know these are of this type\r\n         */\n        keyframes = keyframes;\n        transition = transition;\n        const thisSubject = subjects[subjectIndex];\n        const subjectSequence = getSubjectSequence(thisSubject, sequences);\n        for (const key in keyframes) {\n          resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);\n        }\n      }\n    }\n    prevTime = currentTime;\n    currentTime += maxDuration;\n  }\n  /**\r\n   * For every element and value combination create a new animation.\r\n   */\n  sequences.forEach((valueSequences, element) => {\n    for (const key in valueSequences) {\n      const valueSequence = valueSequences[key];\n      /**\r\n       * Arrange all the keyframes in ascending time order.\r\n       */\n      valueSequence.sort(compareByTime);\n      const keyframes = [];\n      const valueOffset = [];\n      const valueEasing = [];\n      /**\r\n       * For each keyframe, translate absolute times into\r\n       * relative offsets based on the total duration of the timeline.\r\n       */\n      for (let i = 0; i < valueSequence.length; i++) {\n        const {\n          at,\n          value,\n          easing\n        } = valueSequence[i];\n        keyframes.push(value);\n        valueOffset.push(progress(0, totalDuration, at));\n        valueEasing.push(easing || \"easeOut\");\n      }\n      /**\r\n       * If the first keyframe doesn't land on offset: 0\r\n       * provide one by duplicating the initial keyframe. This ensures\r\n       * it snaps to the first keyframe when the animation starts.\r\n       */\n      if (valueOffset[0] !== 0) {\n        valueOffset.unshift(0);\n        keyframes.unshift(keyframes[0]);\n        valueEasing.unshift(defaultSegmentEasing);\n      }\n      /**\r\n       * If the last keyframe doesn't land on offset: 1\r\n       * provide one with a null wildcard value. This will ensure it\r\n       * stays static until the end of the animation.\r\n       */\n      if (valueOffset[valueOffset.length - 1] !== 1) {\n        valueOffset.push(1);\n        keyframes.push(null);\n      }\n      if (!animationDefinitions.has(element)) {\n        animationDefinitions.set(element, {\n          keyframes: {},\n          transition: {}\n        });\n      }\n      const definition = animationDefinitions.get(element);\n      definition.keyframes[key] = keyframes;\n      definition.transition[key] = {\n        ...defaultTransition,\n        duration: totalDuration,\n        ease: valueEasing,\n        times: valueOffset,\n        ...sequenceTransition\n      };\n    }\n  });\n  return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n  !sequences.has(subject) && sequences.set(subject, {});\n  return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n  if (!sequences[name]) sequences[name] = [];\n  return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n  return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n  return transition && transition[key] ? {\n    ...transition,\n    ...transition[key]\n  } : {\n    ...transition\n  };\n}\nconst isNumber = keyframe => typeof keyframe === \"number\";\nconst isNumberKeyframesArray = keyframes => keyframes.every(isNumber);\nexport { createAnimationsFromSequence, getValueTransition };","map":{"version":3,"names":["isGenerator","createGeneratorEasing","progress","secondsToMilliseconds","invariant","getEasingForSegment","defaultOffset","fillOffset","isMotionValue","resolveSubjects","calculateRepeatDuration","calcNextTime","addKeyframes","normalizeTimes","compareByTime","defaultSegmentEasing","MAX_REPEAT","createAnimationsFromSequence","sequence","defaultTransition","sequenceTransition","scope","generators","defaultDuration","duration","animationDefinitions","Map","sequences","elementCache","timeLabels","prevTime","currentTime","totalDuration","i","length","segment","set","Array","isArray","name","at","subject","keyframes","transition","undefined","maxDuration","resolveValueSequence","valueKeyframes","valueTransition","valueSequence","elementIndex","numSubjects","valueKeyframesAsList","keyframesAsList","delay","times","type","repeat","repeatType","repeatDelay","remainingTransition","ease","calculatedDelay","numKeyframes","createGenerator","absoluteDelta","isNumberKeyframesArray","delta","Math","abs","springTransition","springEasing","startTime","remainder","unshift","originalKeyframes","originalTimes","originalEase","repeatIndex","push","keyframeIndex","targetTime","max","subjectSequence","getSubjectSequence","getValueSequence","subjects","subjectIndex","thisSubject","key","getValueTransition","forEach","valueSequences","element","sort","valueOffset","valueEasing","value","easing","has","definition","get","isNumber","keyframe","every"],"sources":["D:/portfolio-master/node_modules/framer-motion/dist/es/animation/sequence/create.mjs"],"sourcesContent":["import { isGenerator, createGeneratorEasing } from 'motion-dom';\r\nimport { progress, secondsToMilliseconds, invariant } from 'motion-utils';\r\nimport { getEasingForSegment } from '../../easing/utils/get-easing-for-segment.mjs';\r\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\r\nimport { fillOffset } from '../../utils/offsets/fill.mjs';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\nimport { resolveSubjects } from '../animate/resolve-subjects.mjs';\r\nimport { calculateRepeatDuration } from './utils/calc-repeat-duration.mjs';\r\nimport { calcNextTime } from './utils/calc-time.mjs';\r\nimport { addKeyframes } from './utils/edit.mjs';\r\nimport { normalizeTimes } from './utils/normalize-times.mjs';\r\nimport { compareByTime } from './utils/sort.mjs';\r\n\r\nconst defaultSegmentEasing = \"easeInOut\";\r\nconst MAX_REPEAT = 20;\r\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {\r\n    const defaultDuration = defaultTransition.duration || 0.3;\r\n    const animationDefinitions = new Map();\r\n    const sequences = new Map();\r\n    const elementCache = {};\r\n    const timeLabels = new Map();\r\n    let prevTime = 0;\r\n    let currentTime = 0;\r\n    let totalDuration = 0;\r\n    /**\r\n     * Build the timeline by mapping over the sequence array and converting\r\n     * the definitions into keyframes and offsets with absolute time values.\r\n     * These will later get converted into relative offsets in a second pass.\r\n     */\r\n    for (let i = 0; i < sequence.length; i++) {\r\n        const segment = sequence[i];\r\n        /**\r\n         * If this is a timeline label, mark it and skip the rest of this iteration.\r\n         */\r\n        if (typeof segment === \"string\") {\r\n            timeLabels.set(segment, currentTime);\r\n            continue;\r\n        }\r\n        else if (!Array.isArray(segment)) {\r\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\r\n            continue;\r\n        }\r\n        let [subject, keyframes, transition = {}] = segment;\r\n        /**\r\n         * If a relative or absolute time value has been specified we need to resolve\r\n         * it in relation to the currentTime.\r\n         */\r\n        if (transition.at !== undefined) {\r\n            currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\r\n        }\r\n        /**\r\n         * Keep track of the maximum duration in this definition. This will be\r\n         * applied to currentTime once the definition has been parsed.\r\n         */\r\n        let maxDuration = 0;\r\n        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {\r\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes);\r\n            const { delay = 0, times = defaultOffset(valueKeyframesAsList), type = \"keyframes\", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;\r\n            let { ease = defaultTransition.ease || \"easeOut\", duration } = valueTransition;\r\n            /**\r\n             * Resolve stagger() if defined.\r\n             */\r\n            const calculatedDelay = typeof delay === \"function\"\r\n                ? delay(elementIndex, numSubjects)\r\n                : delay;\r\n            /**\r\n             * If this animation should and can use a spring, generate a spring easing function.\r\n             */\r\n            const numKeyframes = valueKeyframesAsList.length;\r\n            const createGenerator = isGenerator(type)\r\n                ? type\r\n                : generators === null || generators === void 0 ? void 0 : generators[type];\r\n            if (numKeyframes <= 2 && createGenerator) {\r\n                /**\r\n                 * As we're creating an easing function from a spring,\r\n                 * ideally we want to generate it using the real distance\r\n                 * between the two keyframes. However this isn't always\r\n                 * possible - in these situations we use 0-100.\r\n                 */\r\n                let absoluteDelta = 100;\r\n                if (numKeyframes === 2 &&\r\n                    isNumberKeyframesArray(valueKeyframesAsList)) {\r\n                    const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\r\n                    absoluteDelta = Math.abs(delta);\r\n                }\r\n                const springTransition = { ...remainingTransition };\r\n                if (duration !== undefined) {\r\n                    springTransition.duration = secondsToMilliseconds(duration);\r\n                }\r\n                const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);\r\n                ease = springEasing.ease;\r\n                duration = springEasing.duration;\r\n            }\r\n            duration !== null && duration !== void 0 ? duration : (duration = defaultDuration);\r\n            const startTime = currentTime + calculatedDelay;\r\n            /**\r\n             * If there's only one time offset of 0, fill in a second with length 1\r\n             */\r\n            if (times.length === 1 && times[0] === 0) {\r\n                times[1] = 1;\r\n            }\r\n            /**\r\n             * Fill out if offset if fewer offsets than keyframes\r\n             */\r\n            const remainder = times.length - valueKeyframesAsList.length;\r\n            remainder > 0 && fillOffset(times, remainder);\r\n            /**\r\n             * If only one value has been set, ie [1], push a null to the start of\r\n             * the keyframe array. This will let us mark a keyframe at this point\r\n             * that will later be hydrated with the previous value.\r\n             */\r\n            valueKeyframesAsList.length === 1 &&\r\n                valueKeyframesAsList.unshift(null);\r\n            /**\r\n             * Handle repeat options\r\n             */\r\n            if (repeat) {\r\n                invariant(repeat < MAX_REPEAT, \"Repeat count too high, must be less than 20\");\r\n                duration = calculateRepeatDuration(duration, repeat);\r\n                const originalKeyframes = [...valueKeyframesAsList];\r\n                const originalTimes = [...times];\r\n                ease = Array.isArray(ease) ? [...ease] : [ease];\r\n                const originalEase = [...ease];\r\n                for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\r\n                    valueKeyframesAsList.push(...originalKeyframes);\r\n                    for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {\r\n                        times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));\r\n                        ease.push(keyframeIndex === 0\r\n                            ? \"linear\"\r\n                            : getEasingForSegment(originalEase, keyframeIndex - 1));\r\n                    }\r\n                }\r\n                normalizeTimes(times, repeat);\r\n            }\r\n            const targetTime = startTime + duration;\r\n            /**\r\n             * Add keyframes, mapping offsets to absolute time.\r\n             */\r\n            addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\r\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration);\r\n            totalDuration = Math.max(targetTime, totalDuration);\r\n        };\r\n        if (isMotionValue(subject)) {\r\n            const subjectSequence = getSubjectSequence(subject, sequences);\r\n            resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\r\n        }\r\n        else {\r\n            const subjects = resolveSubjects(subject, keyframes, scope, elementCache);\r\n            const numSubjects = subjects.length;\r\n            /**\r\n             * For every element in this segment, process the defined values.\r\n             */\r\n            for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {\r\n                /**\r\n                 * Cast necessary, but we know these are of this type\r\n                 */\r\n                keyframes = keyframes;\r\n                transition = transition;\r\n                const thisSubject = subjects[subjectIndex];\r\n                const subjectSequence = getSubjectSequence(thisSubject, sequences);\r\n                for (const key in keyframes) {\r\n                    resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);\r\n                }\r\n            }\r\n        }\r\n        prevTime = currentTime;\r\n        currentTime += maxDuration;\r\n    }\r\n    /**\r\n     * For every element and value combination create a new animation.\r\n     */\r\n    sequences.forEach((valueSequences, element) => {\r\n        for (const key in valueSequences) {\r\n            const valueSequence = valueSequences[key];\r\n            /**\r\n             * Arrange all the keyframes in ascending time order.\r\n             */\r\n            valueSequence.sort(compareByTime);\r\n            const keyframes = [];\r\n            const valueOffset = [];\r\n            const valueEasing = [];\r\n            /**\r\n             * For each keyframe, translate absolute times into\r\n             * relative offsets based on the total duration of the timeline.\r\n             */\r\n            for (let i = 0; i < valueSequence.length; i++) {\r\n                const { at, value, easing } = valueSequence[i];\r\n                keyframes.push(value);\r\n                valueOffset.push(progress(0, totalDuration, at));\r\n                valueEasing.push(easing || \"easeOut\");\r\n            }\r\n            /**\r\n             * If the first keyframe doesn't land on offset: 0\r\n             * provide one by duplicating the initial keyframe. This ensures\r\n             * it snaps to the first keyframe when the animation starts.\r\n             */\r\n            if (valueOffset[0] !== 0) {\r\n                valueOffset.unshift(0);\r\n                keyframes.unshift(keyframes[0]);\r\n                valueEasing.unshift(defaultSegmentEasing);\r\n            }\r\n            /**\r\n             * If the last keyframe doesn't land on offset: 1\r\n             * provide one with a null wildcard value. This will ensure it\r\n             * stays static until the end of the animation.\r\n             */\r\n            if (valueOffset[valueOffset.length - 1] !== 1) {\r\n                valueOffset.push(1);\r\n                keyframes.push(null);\r\n            }\r\n            if (!animationDefinitions.has(element)) {\r\n                animationDefinitions.set(element, {\r\n                    keyframes: {},\r\n                    transition: {},\r\n                });\r\n            }\r\n            const definition = animationDefinitions.get(element);\r\n            definition.keyframes[key] = keyframes;\r\n            definition.transition[key] = {\r\n                ...defaultTransition,\r\n                duration: totalDuration,\r\n                ease: valueEasing,\r\n                times: valueOffset,\r\n                ...sequenceTransition,\r\n            };\r\n        }\r\n    });\r\n    return animationDefinitions;\r\n}\r\nfunction getSubjectSequence(subject, sequences) {\r\n    !sequences.has(subject) && sequences.set(subject, {});\r\n    return sequences.get(subject);\r\n}\r\nfunction getValueSequence(name, sequences) {\r\n    if (!sequences[name])\r\n        sequences[name] = [];\r\n    return sequences[name];\r\n}\r\nfunction keyframesAsList(keyframes) {\r\n    return Array.isArray(keyframes) ? keyframes : [keyframes];\r\n}\r\nfunction getValueTransition(transition, key) {\r\n    return transition && transition[key]\r\n        ? {\r\n            ...transition,\r\n            ...transition[key],\r\n        }\r\n        : { ...transition };\r\n}\r\nconst isNumber = (keyframe) => typeof keyframe === \"number\";\r\nconst isNumberKeyframesArray = (keyframes) => keyframes.every(isNumber);\r\n\r\nexport { createAnimationsFromSequence, getValueTransition };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}