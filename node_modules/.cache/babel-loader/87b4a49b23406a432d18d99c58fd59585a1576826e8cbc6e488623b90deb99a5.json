{"ast":null,"code":"import { floatRegex } from '../utils/float-regex.mjs';\nimport { isNullish } from '../utils/is-nullish.mjs';\nimport { singleColorRegex } from '../utils/single-color-regex.mjs';\n\n/**\r\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\r\n * but false if a number or multiple colors\r\n */\nconst isColorString = (type, testProp) => v => {\n  return Boolean(typeof v === \"string\" && singleColorRegex.test(v) && v.startsWith(type) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp));\n};\nconst splitColor = (aName, bName, cName) => v => {\n  if (typeof v !== \"string\") return v;\n  const [a, b, c, alpha] = v.match(floatRegex);\n  return {\n    [aName]: parseFloat(a),\n    [bName]: parseFloat(b),\n    [cName]: parseFloat(c),\n    alpha: alpha !== undefined ? parseFloat(alpha) : 1\n  };\n};\nexport { isColorString, splitColor };","map":{"version":3,"names":["floatRegex","isNullish","singleColorRegex","isColorString","type","testProp","v","Boolean","test","startsWith","Object","prototype","hasOwnProperty","call","splitColor","aName","bName","cName","a","b","c","alpha","match","parseFloat","undefined"],"sources":["D:/portfolio-master/node_modules/framer-motion/dist/es/value/types/color/utils.mjs"],"sourcesContent":["import { floatRegex } from '../utils/float-regex.mjs';\r\nimport { isNullish } from '../utils/is-nullish.mjs';\r\nimport { singleColorRegex } from '../utils/single-color-regex.mjs';\r\n\r\n/**\r\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\r\n * but false if a number or multiple colors\r\n */\r\nconst isColorString = (type, testProp) => (v) => {\r\n    return Boolean((typeof v === \"string\" &&\r\n        singleColorRegex.test(v) &&\r\n        v.startsWith(type)) ||\r\n        (testProp &&\r\n            !isNullish(v) &&\r\n            Object.prototype.hasOwnProperty.call(v, testProp)));\r\n};\r\nconst splitColor = (aName, bName, cName) => (v) => {\r\n    if (typeof v !== \"string\")\r\n        return v;\r\n    const [a, b, c, alpha] = v.match(floatRegex);\r\n    return {\r\n        [aName]: parseFloat(a),\r\n        [bName]: parseFloat(b),\r\n        [cName]: parseFloat(c),\r\n        alpha: alpha !== undefined ? parseFloat(alpha) : 1,\r\n    };\r\n};\r\n\r\nexport { isColorString, splitColor };\r\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ,0BAA0B;AACrD,SAASC,SAAS,QAAQ,yBAAyB;AACnD,SAASC,gBAAgB,QAAQ,iCAAiC;;AAElE;AACA;AACA;AACA;AACA,MAAMC,aAAa,GAAGA,CAACC,IAAI,EAAEC,QAAQ,KAAMC,CAAC,IAAK;EAC7C,OAAOC,OAAO,CAAE,OAAOD,CAAC,KAAK,QAAQ,IACjCJ,gBAAgB,CAACM,IAAI,CAACF,CAAC,CAAC,IACxBA,CAAC,CAACG,UAAU,CAACL,IAAI,CAAC,IACjBC,QAAQ,IACL,CAACJ,SAAS,CAACK,CAAC,CAAC,IACbI,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACP,CAAC,EAAED,QAAQ,CAAE,CAAC;AAC/D,CAAC;AACD,MAAMS,UAAU,GAAGA,CAACC,KAAK,EAAEC,KAAK,EAAEC,KAAK,KAAMX,CAAC,IAAK;EAC/C,IAAI,OAAOA,CAAC,KAAK,QAAQ,EACrB,OAAOA,CAAC;EACZ,MAAM,CAACY,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,CAAC,GAAGf,CAAC,CAACgB,KAAK,CAACtB,UAAU,CAAC;EAC5C,OAAO;IACH,CAACe,KAAK,GAAGQ,UAAU,CAACL,CAAC,CAAC;IACtB,CAACF,KAAK,GAAGO,UAAU,CAACJ,CAAC,CAAC;IACtB,CAACF,KAAK,GAAGM,UAAU,CAACH,CAAC,CAAC;IACtBC,KAAK,EAAEA,KAAK,KAAKG,SAAS,GAAGD,UAAU,CAACF,KAAK,CAAC,GAAG;EACrD,CAAC;AACL,CAAC;AAED,SAASlB,aAAa,EAAEW,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}