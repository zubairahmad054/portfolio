{"ast":null,"code":"\"use client\";\n\nimport { jsx } from 'react/jsx-runtime';\nimport * as React from 'react';\nimport { useId, useCallback, useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { PopChild } from './PopChild.mjs';\nconst PresenceChild = _ref => {\n  let {\n    children,\n    initial,\n    isPresent,\n    onExitComplete,\n    custom,\n    presenceAffectsLayout,\n    mode,\n    anchorX\n  } = _ref;\n  const presenceChildren = useConstant(newChildrenMap);\n  const id = useId();\n  const memoizedOnExitComplete = useCallback(childId => {\n    presenceChildren.set(childId, true);\n    for (const isComplete of presenceChildren.values()) {\n      if (!isComplete) return; // can stop searching when any is incomplete\n    }\n    onExitComplete && onExitComplete();\n  }, [presenceChildren, onExitComplete]);\n  const context = useMemo(() => ({\n    id,\n    initial,\n    isPresent,\n    custom,\n    onExitComplete: memoizedOnExitComplete,\n    register: childId => {\n      presenceChildren.set(childId, false);\n      return () => presenceChildren.delete(childId);\n    }\n  }),\n  /**\r\n   * If the presence of a child affects the layout of the components around it,\r\n   * we want to make a new context value to ensure they get re-rendered\r\n   * so they can detect that layout change.\r\n   */\n  presenceAffectsLayout ? [Math.random(), memoizedOnExitComplete] : [isPresent, memoizedOnExitComplete]);\n  useMemo(() => {\n    presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\n  }, [isPresent]);\n  /**\r\n   * If there's no `motion` components to fire exit animations, we want to remove this\r\n   * component immediately.\r\n   */\n  React.useEffect(() => {\n    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();\n  }, [isPresent]);\n  if (mode === \"popLayout\") {\n    children = jsx(PopChild, {\n      isPresent: isPresent,\n      anchorX: anchorX,\n      children: children\n    });\n  }\n  return jsx(PresenceContext.Provider, {\n    value: context,\n    children: children\n  });\n};\nfunction newChildrenMap() {\n  return new Map();\n}\nexport { PresenceChild };","map":{"version":3,"names":["jsx","React","useId","useCallback","useMemo","PresenceContext","useConstant","PopChild","PresenceChild","_ref","children","initial","isPresent","onExitComplete","custom","presenceAffectsLayout","mode","anchorX","presenceChildren","newChildrenMap","id","memoizedOnExitComplete","childId","set","isComplete","values","context","register","delete","Math","random","forEach","_","key","useEffect","size","Provider","value","Map"],"sources":["D:/portfolio-master/node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs"],"sourcesContent":["\"use client\";\r\nimport { jsx } from 'react/jsx-runtime';\r\nimport * as React from 'react';\r\nimport { useId, useCallback, useMemo } from 'react';\r\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\r\nimport { useConstant } from '../../utils/use-constant.mjs';\r\nimport { PopChild } from './PopChild.mjs';\r\n\r\nconst PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, }) => {\r\n    const presenceChildren = useConstant(newChildrenMap);\r\n    const id = useId();\r\n    const memoizedOnExitComplete = useCallback((childId) => {\r\n        presenceChildren.set(childId, true);\r\n        for (const isComplete of presenceChildren.values()) {\r\n            if (!isComplete)\r\n                return; // can stop searching when any is incomplete\r\n        }\r\n        onExitComplete && onExitComplete();\r\n    }, [presenceChildren, onExitComplete]);\r\n    const context = useMemo(() => ({\r\n        id,\r\n        initial,\r\n        isPresent,\r\n        custom,\r\n        onExitComplete: memoizedOnExitComplete,\r\n        register: (childId) => {\r\n            presenceChildren.set(childId, false);\r\n            return () => presenceChildren.delete(childId);\r\n        },\r\n    }), \r\n    /**\r\n     * If the presence of a child affects the layout of the components around it,\r\n     * we want to make a new context value to ensure they get re-rendered\r\n     * so they can detect that layout change.\r\n     */\r\n    presenceAffectsLayout\r\n        ? [Math.random(), memoizedOnExitComplete]\r\n        : [isPresent, memoizedOnExitComplete]);\r\n    useMemo(() => {\r\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\r\n    }, [isPresent]);\r\n    /**\r\n     * If there's no `motion` components to fire exit animations, we want to remove this\r\n     * component immediately.\r\n     */\r\n    React.useEffect(() => {\r\n        !isPresent &&\r\n            !presenceChildren.size &&\r\n            onExitComplete &&\r\n            onExitComplete();\r\n    }, [isPresent]);\r\n    if (mode === \"popLayout\") {\r\n        children = (jsx(PopChild, { isPresent: isPresent, anchorX: anchorX, children: children }));\r\n    }\r\n    return (jsx(PresenceContext.Provider, { value: context, children: children }));\r\n};\r\nfunction newChildrenMap() {\r\n    return new Map();\r\n}\r\n\r\nexport { PresenceChild };\r\n"],"mappings":"AAAA,YAAY;;AACZ,SAASA,GAAG,QAAQ,mBAAmB;AACvC,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,SAASC,KAAK,EAAEC,WAAW,EAAEC,OAAO,QAAQ,OAAO;AACnD,SAASC,eAAe,QAAQ,mCAAmC;AACnE,SAASC,WAAW,QAAQ,8BAA8B;AAC1D,SAASC,QAAQ,QAAQ,gBAAgB;AAEzC,MAAMC,aAAa,GAAGC,IAAA,IAAqG;EAAA,IAApG;IAAEC,QAAQ;IAAEC,OAAO;IAAEC,SAAS;IAAEC,cAAc;IAAEC,MAAM;IAAEC,qBAAqB;IAAEC,IAAI;IAAEC;EAAS,CAAC,GAAAR,IAAA;EAClH,MAAMS,gBAAgB,GAAGZ,WAAW,CAACa,cAAc,CAAC;EACpD,MAAMC,EAAE,GAAGlB,KAAK,CAAC,CAAC;EAClB,MAAMmB,sBAAsB,GAAGlB,WAAW,CAAEmB,OAAO,IAAK;IACpDJ,gBAAgB,CAACK,GAAG,CAACD,OAAO,EAAE,IAAI,CAAC;IACnC,KAAK,MAAME,UAAU,IAAIN,gBAAgB,CAACO,MAAM,CAAC,CAAC,EAAE;MAChD,IAAI,CAACD,UAAU,EACX,OAAO,CAAC;IAChB;IACAX,cAAc,IAAIA,cAAc,CAAC,CAAC;EACtC,CAAC,EAAE,CAACK,gBAAgB,EAAEL,cAAc,CAAC,CAAC;EACtC,MAAMa,OAAO,GAAGtB,OAAO,CAAC,OAAO;IAC3BgB,EAAE;IACFT,OAAO;IACPC,SAAS;IACTE,MAAM;IACND,cAAc,EAAEQ,sBAAsB;IACtCM,QAAQ,EAAGL,OAAO,IAAK;MACnBJ,gBAAgB,CAACK,GAAG,CAACD,OAAO,EAAE,KAAK,CAAC;MACpC,OAAO,MAAMJ,gBAAgB,CAACU,MAAM,CAACN,OAAO,CAAC;IACjD;EACJ,CAAC,CAAC;EACF;AACJ;AACA;AACA;AACA;EACIP,qBAAqB,GACf,CAACc,IAAI,CAACC,MAAM,CAAC,CAAC,EAAET,sBAAsB,CAAC,GACvC,CAACT,SAAS,EAAES,sBAAsB,CAAC,CAAC;EAC1CjB,OAAO,CAAC,MAAM;IACVc,gBAAgB,CAACa,OAAO,CAAC,CAACC,CAAC,EAAEC,GAAG,KAAKf,gBAAgB,CAACK,GAAG,CAACU,GAAG,EAAE,KAAK,CAAC,CAAC;EAC1E,CAAC,EAAE,CAACrB,SAAS,CAAC,CAAC;EACf;AACJ;AACA;AACA;EACIX,KAAK,CAACiC,SAAS,CAAC,MAAM;IAClB,CAACtB,SAAS,IACN,CAACM,gBAAgB,CAACiB,IAAI,IACtBtB,cAAc,IACdA,cAAc,CAAC,CAAC;EACxB,CAAC,EAAE,CAACD,SAAS,CAAC,CAAC;EACf,IAAII,IAAI,KAAK,WAAW,EAAE;IACtBN,QAAQ,GAAIV,GAAG,CAACO,QAAQ,EAAE;MAAEK,SAAS,EAAEA,SAAS;MAAEK,OAAO,EAAEA,OAAO;MAAEP,QAAQ,EAAEA;IAAS,CAAC,CAAE;EAC9F;EACA,OAAQV,GAAG,CAACK,eAAe,CAAC+B,QAAQ,EAAE;IAAEC,KAAK,EAAEX,OAAO;IAAEhB,QAAQ,EAAEA;EAAS,CAAC,CAAC;AACjF,CAAC;AACD,SAASS,cAAcA,CAAA,EAAG;EACtB,OAAO,IAAImB,GAAG,CAAC,CAAC;AACpB;AAEA,SAAS9B,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}