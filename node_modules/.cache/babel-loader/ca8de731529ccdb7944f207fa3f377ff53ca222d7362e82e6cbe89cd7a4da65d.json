{"ast":null,"code":"\"use client\";\n\nimport { jsx, Fragment } from 'react/jsx-runtime';\nimport { useMemo, useRef, useState, useContext } from 'react';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { usePresence } from './use-presence.mjs';\nimport { onlyElements, getChildKey } from './utils.mjs';\n\n/**\r\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\r\n *\r\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\r\n *\r\n * Any `motion` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { motion, AnimatePresence } from 'framer-motion'\r\n *\r\n * export const Items = ({ items }) => (\r\n *   <AnimatePresence>\r\n *     {items.map(item => (\r\n *       <motion.div\r\n *         key={item.id}\r\n *         initial={{ opacity: 0 }}\r\n *         animate={{ opacity: 1 }}\r\n *         exit={{ opacity: 0 }}\r\n *       />\r\n *     ))}\r\n *   </AnimatePresence>\r\n * )\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\r\n * once all `motion` components have finished animating out. Likewise, any components using\r\n * `usePresence` all need to call `safeToRemove`.\r\n *\r\n * @public\r\n */\nconst AnimatePresence = ({\n  children,\n  custom,\n  initial = true,\n  onExitComplete,\n  presenceAffectsLayout = true,\n  mode = \"sync\",\n  propagate = false,\n  anchorX = \"left\"\n}) => {\n  const [isParentPresent, safeToRemove] = usePresence(propagate);\n  /**\r\n   * Filter any children that aren't ReactElements. We can only track components\r\n   * between renders with a props.key.\r\n   */\n  const presentChildren = useMemo(() => onlyElements(children), [children]);\n  /**\r\n   * Track the keys of the currently rendered children. This is used to\r\n   * determine which children are exiting.\r\n   */\n  const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);\n  /**\r\n   * If `initial={false}` we only want to pass this to components in the first render.\r\n   */\n  const isInitialRender = useRef(true);\n  /**\r\n   * A ref containing the currently present children. When all exit animations\r\n   * are complete, we use this to re-render the component with the latest children\r\n   * *committed* rather than the latest children *rendered*.\r\n   */\n  const pendingPresentChildren = useRef(presentChildren);\n  /**\r\n   * Track which exiting children have finished animating out.\r\n   */\n  const exitComplete = useConstant(() => new Map());\n  /**\r\n   * Save children to render as React state. To ensure this component is concurrent-safe,\r\n   * we check for exiting children via an effect.\r\n   */\n  const [diffedChildren, setDiffedChildren] = useState(presentChildren);\n  const [renderedChildren, setRenderedChildren] = useState(presentChildren);\n  useIsomorphicLayoutEffect(() => {\n    isInitialRender.current = false;\n    pendingPresentChildren.current = presentChildren;\n    /**\r\n     * Update complete status of exiting children.\r\n     */\n    for (let i = 0; i < renderedChildren.length; i++) {\n      const key = getChildKey(renderedChildren[i]);\n      if (!presentKeys.includes(key)) {\n        if (exitComplete.get(key) !== true) {\n          exitComplete.set(key, false);\n        }\n      } else {\n        exitComplete.delete(key);\n      }\n    }\n  }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")]);\n  const exitingChildren = [];\n  if (presentChildren !== diffedChildren) {\n    let nextChildren = [...presentChildren];\n    /**\r\n     * Loop through all the currently rendered components and decide which\r\n     * are exiting.\r\n     */\n    for (let i = 0; i < renderedChildren.length; i++) {\n      const child = renderedChildren[i];\n      const key = getChildKey(child);\n      if (!presentKeys.includes(key)) {\n        nextChildren.splice(i, 0, child);\n        exitingChildren.push(child);\n      }\n    }\n    /**\r\n     * If we're in \"wait\" mode, and we have exiting children, we want to\r\n     * only render these until they've all exited.\r\n     */\n    if (mode === \"wait\" && exitingChildren.length) {\n      nextChildren = exitingChildren;\n    }\n    setRenderedChildren(onlyElements(nextChildren));\n    setDiffedChildren(presentChildren);\n    /**\r\n     * Early return to ensure once we've set state with the latest diffed\r\n     * children, we can immediately re-render.\r\n     */\n    return null;\n  }\n  if (process.env.NODE_ENV !== \"production\" && mode === \"wait\" && renderedChildren.length > 1) {\n    console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n  }\n  /**\r\n   * If we've been provided a forceRender function by the LayoutGroupContext,\r\n   * we can use it to force a re-render amongst all surrounding components once\r\n   * all components have finished animating out.\r\n   */\n  const {\n    forceRender\n  } = useContext(LayoutGroupContext);\n  return jsx(Fragment, {\n    children: renderedChildren.map(child => {\n      const key = getChildKey(child);\n      const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);\n      const onExit = () => {\n        if (exitComplete.has(key)) {\n          exitComplete.set(key, true);\n        } else {\n          return;\n        }\n        let isEveryExitComplete = true;\n        exitComplete.forEach(isExitComplete => {\n          if (!isExitComplete) isEveryExitComplete = false;\n        });\n        if (isEveryExitComplete) {\n          forceRender === null || forceRender === void 0 ? void 0 : forceRender();\n          setRenderedChildren(pendingPresentChildren.current);\n          propagate && (safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove());\n          onExitComplete && onExitComplete();\n        }\n      };\n      return jsx(PresenceChild, {\n        isPresent: isPresent,\n        initial: !isInitialRender.current || initial ? undefined : false,\n        custom: custom,\n        presenceAffectsLayout: presenceAffectsLayout,\n        mode: mode,\n        onExitComplete: isPresent ? undefined : onExit,\n        anchorX: anchorX,\n        children: child\n      }, key);\n    })\n  });\n};\nexport { AnimatePresence };","map":{"version":3,"names":["jsx","Fragment","useMemo","useRef","useState","useContext","LayoutGroupContext","useConstant","useIsomorphicLayoutEffect","PresenceChild","usePresence","onlyElements","getChildKey","AnimatePresence","children","custom","initial","onExitComplete","presenceAffectsLayout","mode","propagate","anchorX","isParentPresent","safeToRemove","presentChildren","presentKeys","map","isInitialRender","pendingPresentChildren","exitComplete","Map","diffedChildren","setDiffedChildren","renderedChildren","setRenderedChildren","current","i","length","key","includes","get","set","delete","join","exitingChildren","nextChildren","child","splice","push","process","env","NODE_ENV","console","warn","forceRender","isPresent","onExit","has","isEveryExitComplete","forEach","isExitComplete","undefined"],"sources":["D:/portfolio-master/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs"],"sourcesContent":["\"use client\";\r\nimport { jsx, Fragment } from 'react/jsx-runtime';\r\nimport { useMemo, useRef, useState, useContext } from 'react';\r\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\r\nimport { useConstant } from '../../utils/use-constant.mjs';\r\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\r\nimport { PresenceChild } from './PresenceChild.mjs';\r\nimport { usePresence } from './use-presence.mjs';\r\nimport { onlyElements, getChildKey } from './utils.mjs';\r\n\r\n/**\r\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\r\n *\r\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\r\n *\r\n * Any `motion` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { motion, AnimatePresence } from 'framer-motion'\r\n *\r\n * export const Items = ({ items }) => (\r\n *   <AnimatePresence>\r\n *     {items.map(item => (\r\n *       <motion.div\r\n *         key={item.id}\r\n *         initial={{ opacity: 0 }}\r\n *         animate={{ opacity: 1 }}\r\n *         exit={{ opacity: 0 }}\r\n *       />\r\n *     ))}\r\n *   </AnimatePresence>\r\n * )\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\r\n * once all `motion` components have finished animating out. Likewise, any components using\r\n * `usePresence` all need to call `safeToRemove`.\r\n *\r\n * @public\r\n */\r\nconst AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = \"sync\", propagate = false, anchorX = \"left\", }) => {\r\n    const [isParentPresent, safeToRemove] = usePresence(propagate);\r\n    /**\r\n     * Filter any children that aren't ReactElements. We can only track components\r\n     * between renders with a props.key.\r\n     */\r\n    const presentChildren = useMemo(() => onlyElements(children), [children]);\r\n    /**\r\n     * Track the keys of the currently rendered children. This is used to\r\n     * determine which children are exiting.\r\n     */\r\n    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);\r\n    /**\r\n     * If `initial={false}` we only want to pass this to components in the first render.\r\n     */\r\n    const isInitialRender = useRef(true);\r\n    /**\r\n     * A ref containing the currently present children. When all exit animations\r\n     * are complete, we use this to re-render the component with the latest children\r\n     * *committed* rather than the latest children *rendered*.\r\n     */\r\n    const pendingPresentChildren = useRef(presentChildren);\r\n    /**\r\n     * Track which exiting children have finished animating out.\r\n     */\r\n    const exitComplete = useConstant(() => new Map());\r\n    /**\r\n     * Save children to render as React state. To ensure this component is concurrent-safe,\r\n     * we check for exiting children via an effect.\r\n     */\r\n    const [diffedChildren, setDiffedChildren] = useState(presentChildren);\r\n    const [renderedChildren, setRenderedChildren] = useState(presentChildren);\r\n    useIsomorphicLayoutEffect(() => {\r\n        isInitialRender.current = false;\r\n        pendingPresentChildren.current = presentChildren;\r\n        /**\r\n         * Update complete status of exiting children.\r\n         */\r\n        for (let i = 0; i < renderedChildren.length; i++) {\r\n            const key = getChildKey(renderedChildren[i]);\r\n            if (!presentKeys.includes(key)) {\r\n                if (exitComplete.get(key) !== true) {\r\n                    exitComplete.set(key, false);\r\n                }\r\n            }\r\n            else {\r\n                exitComplete.delete(key);\r\n            }\r\n        }\r\n    }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")]);\r\n    const exitingChildren = [];\r\n    if (presentChildren !== diffedChildren) {\r\n        let nextChildren = [...presentChildren];\r\n        /**\r\n         * Loop through all the currently rendered components and decide which\r\n         * are exiting.\r\n         */\r\n        for (let i = 0; i < renderedChildren.length; i++) {\r\n            const child = renderedChildren[i];\r\n            const key = getChildKey(child);\r\n            if (!presentKeys.includes(key)) {\r\n                nextChildren.splice(i, 0, child);\r\n                exitingChildren.push(child);\r\n            }\r\n        }\r\n        /**\r\n         * If we're in \"wait\" mode, and we have exiting children, we want to\r\n         * only render these until they've all exited.\r\n         */\r\n        if (mode === \"wait\" && exitingChildren.length) {\r\n            nextChildren = exitingChildren;\r\n        }\r\n        setRenderedChildren(onlyElements(nextChildren));\r\n        setDiffedChildren(presentChildren);\r\n        /**\r\n         * Early return to ensure once we've set state with the latest diffed\r\n         * children, we can immediately re-render.\r\n         */\r\n        return null;\r\n    }\r\n    if (process.env.NODE_ENV !== \"production\" &&\r\n        mode === \"wait\" &&\r\n        renderedChildren.length > 1) {\r\n        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\r\n    }\r\n    /**\r\n     * If we've been provided a forceRender function by the LayoutGroupContext,\r\n     * we can use it to force a re-render amongst all surrounding components once\r\n     * all components have finished animating out.\r\n     */\r\n    const { forceRender } = useContext(LayoutGroupContext);\r\n    return (jsx(Fragment, { children: renderedChildren.map((child) => {\r\n            const key = getChildKey(child);\r\n            const isPresent = propagate && !isParentPresent\r\n                ? false\r\n                : presentChildren === renderedChildren ||\r\n                    presentKeys.includes(key);\r\n            const onExit = () => {\r\n                if (exitComplete.has(key)) {\r\n                    exitComplete.set(key, true);\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n                let isEveryExitComplete = true;\r\n                exitComplete.forEach((isExitComplete) => {\r\n                    if (!isExitComplete)\r\n                        isEveryExitComplete = false;\r\n                });\r\n                if (isEveryExitComplete) {\r\n                    forceRender === null || forceRender === void 0 ? void 0 : forceRender();\r\n                    setRenderedChildren(pendingPresentChildren.current);\r\n                    propagate && (safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove());\r\n                    onExitComplete && onExitComplete();\r\n                }\r\n            };\r\n            return (jsx(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial\r\n                    ? undefined\r\n                    : false, custom: custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, onExitComplete: isPresent ? undefined : onExit, anchorX: anchorX, children: child }, key));\r\n        }) }));\r\n};\r\n\r\nexport { AnimatePresence };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}